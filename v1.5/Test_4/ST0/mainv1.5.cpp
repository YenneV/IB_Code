#include <iostream>#include <iomanip>#include <string.h>#include <sstream>#include <fstream>#include <math.h>#include <complex>#include <nag.h>#include <nag_stdlib.h>#include <nagc06.h>#include <nagf11.h>#include <nagf04.h>#include <nagf07.h>#include <vector>//Made shape update RK4 method//Upwind scheme for dpdt equations//Walls simulated as array of solid points//simple projection method soultion with FFT//x lattice at i,j+1/2//y lattice at i+1/2,j//P lattice at i+1/2,j+1/2//1D lagrangian mesh for boundary//s lattice at k//s1 lattice at k+1/2using namespace std;#include "./simops.cpp"  //options file/*Start from input?*/         const bool FROMFILE = false;  //start from file input (else start from t=0)//move boundary start file to boundary.in//if BULKPOL used move starting bulk file to bulk.in//if WALLS used move walls start file to walls.in/***IF NOT USING SHELL SCRIPT TO RUN YOU WILL NEED TO DEFINE THESE***//*#define CONC true        //active boundary?#define BULKPOL true   //include active fluid inside?#define WALLS true    //include walls?const int Lx = 160;    //No. of points in x and yconst int Ly = 80;double ST = 1.0;   //surface tension#if BULKPOLdouble Zeta = 0;   //bulk activitydouble K = 0.1;  //elastic constant#endif#if CONCdouble Zc = 0;    //boundary activitydouble koff = 0;    //unbinding rate*//* Grid dimensions */const double h = 1.0;  //grid spacing/*Boundary dimensions*/const int smax = 1000; const double R0 = 17.0;    //I don't need this but leaving in for now in case of errors const double ds = (30*h);    //arc length between initial boundary points/* Timesteps */int t = -1;const int Nmax=200000;     // total number of iterations const int stepskip=250; //output every t=stepskip, changed from 20,000const int velskip=1000;    //output velocity every t=stepskipconst double dt = 1.0;struct field    //structure for storing surface and bulk parts of a quantity{  double bulk[Lx*Ly];  double surface[smax];};double xlength = Lx*h;    //Length of grid in x double ylength = Ly*h;	  //Length of grid in yint Ls = (xlength)/30*h;     //Length of boundary, so that ds ~ 0.5dx/* Fluid parameters */double eta = 1.0;  //fluid viscositydouble eta1 = 1.0;  //external viscositydouble Gamma = 1.0;  //rotational viscosity#if CONC/* Concentration parameters */double conc0 = 1.0;   //initial concentrationdouble kon = koff;   // koff is set by user, kon set as equal to binding and unbinding at same ratedouble Df=0.05;   //diffusion constantdouble B=0.5;   //pressure constantdouble Dfb=0.1; //bulk diffusion constantdouble cbulk0= koff*conc0/kon;   //steady state concentration#endif #if BULKPOL/* Active gel parameters */double nu = -1.1;     //liquid crystal parameterdouble W1 = 0.0001;   //normal anchoring magnitudedouble c0 = 2.5;   //internal concentration#endif#if WALLS/*Wall parameters*/int Nsw = 0;  //to be calculateddouble WF=1;  //wall forcedouble s_width = ylength - 4*h;  //wall width at x=0double chan_width = s_width;    //constriction widthdouble transition_length = xlength/8;   //length of part of tube between constriction and wide part#endif/*General functions*/int initialise(void);void printout(int t);void old_values(void);/*Fluid functions*/void fourier_solve(void);void update(int t);void update_H(void);#if BULKPOL/*Bulk functions*/void calc_force(void);void pol_calc(void);#endif#if CONC/*Cortex functions*/void update_concentration(void);#endif#if WALLSdouble bottom_wall_position(double xh);     //bottom wall position as a function of xdouble top_wall_position(double xh);        //top wall position as a function of x#endif/*Boundary functions*/void boundary_force();void boundary_vel(void);void add(int a);	//adds a boundary pointvoid remove(int a);     //remove a boundary point(int a)void remesh(void);void area_check(void);void update_spacing(void);void update_tlat(void);void perturbation(void);void mode_calc(void);void print_modes(void);/* Fluid Variables */double x[Lx];      //x coordinatesdouble y[Ly];	   //y coordinatesdouble xp[Lx];     //x1 coordinatesdouble yp[Ly];	   //y1 coordinatesfield ux;     //velocityfield uy;    field P;      //pressuredouble uxold[Lx*Ly];     //velocity at time n-1double uyold[Lx*Ly];double uxp[Lx*Ly],uyp[Lx*Ly],uxpi[Lx*Ly],uypi[Lx*Ly],fxp[Lx*Ly],fyp[Lx*Ly],fxpi[Lx*Ly],fypi[Lx*Ly];   //fourier transformed values, real and imagdouble uxi[Lx*Ly],uyi[Lx*Ly];   //imag part of velocity and pressure, should be 0double fx[Lx*Ly];      //total force on fluiddouble fy[Lx*Ly];       double H[Lx*Ly];     //heaviside functiondouble Hold[Lx*Ly];    //H at n-1double epsilon = 1E-06;double dxH[Lx*Ly];double dyH[Lx*Ly];  //derivatives of heavisideconst int Nmodes=4;  //number of modes to checkdouble xcomp=0, ycomp=0, xcold=0, ycold=0, Vxcom, Vycom, kmode[Nmodes], kmodeim[Nmodes]; //xcomp is proper centre of mass#if BULKPOL/* Active gel variables*/double mux[Lx*Ly];     //dpdtdouble muy[Lx*Ly];double px[Lx*Ly];    //polarisation double py[Lx*Ly];double hx[Lx*Ly];    //molecular fielddouble hy[Lx*Ly];double sxx[Lx*Ly];    //stressesdouble sxy[Lx*Ly];double syx[Lx*Ly];   double syy[Lx*Ly];#endif/*boundary variables*/double dxh[smax],dyh[smax],tvx[smax],tvy[smax],nvx[smax],nvy[smax],stx[smax],sty[smax],X[smax],Y[smax],Xp[smax],Yp[smax],Xt[smax],Yt[smax],Fx[smax],Fy[smax],Fn[smax],Xtold[smax],Ytold[smax],Xpold[smax],Ypold[smax],Rh[smax];int icom,jcom;double xcom,ycom;    //approximate centre of massdouble slength,area,oldarea;     //current boundary total length#if CONC/*Concentration variables*/double dtc[smax],muc[smax],cmode[Nmodes],cmodeim[Nmodes];field c; //bulk concentrationdouble Cs[smax];  //concentration bound to surfacedouble masstot, dmasstot;#endif#if WALLS/*Wall variables*/double *Xw0, *Yw0, *Xw0i, *Yw0i, *Fxw0, *Fyw0, *Vxw0, *Vyw0;#endif/* mathematical functions */double dxf_(double f[Lx*Ly], int i, int j);    //fwd diff functionsdouble dyf_(double f[Lx*Ly], int i, int j);    double dxb_(double f[Lx*Ly], int i, int j);    //bwd diff functionsdouble dyb_(double f[Lx*Ly], int i, int j);double dx2_(double f[Lx*Ly], int i, int j);   //central diffdouble dy2_(double f[Lx*Ly], int i, int j);double vdelx(double f[Lx*Ly], double v, int i, int j);double vdely(double f[Lx*Ly], double v, int i, int j); //upwind schemedouble dsf_(double *f, int s);    //fwd boundary gradient for f on s latticedouble dsb_(double *f, int s);    //bwd boundary gradient for f on s1 latticedouble ds2_(double *f, int s);int ip(int i, int p);int jp(int j, int p);int sp(int s, int p);double deltah(double xi, double yj, double Xs, double Ys);       //soft delta functiondouble phir(double r);                    //factors of delta functiondouble drand48(void);double p2xlat(double *f, int n);double p2ylat(double *f, int n);double p2blat(double *f, int n);double x2plat(double *f, int n);double y2plat(double *f, int n);int Xi(double Xs);    int Yj(double Ys);int Xi1(double Xs);int Yj1(double Ys);string gnuheader(void);void plotfile(void);int main(int argc, char* argv[]){  int i,j,s;  int np = 0;#if CONC  Zc -= B;  //turn effective activty to activity  if(koff==0) kon=1;#endif  if(initialise()) return 1;  plotfile();  for(t=0;t<=Nmax;t++)    {      cout << "Time Point: " << t << " ," ;      //if(t%velskip==0) print_modes();      //if(t==5000 && FROMFILE==false) perturbation();      old_values();      boundary_force();#if BULKPOL      calc_force();#endif            fourier_solve();#if BULKPOL      pol_calc();#endif      boundary_vel();      if(t%stepskip==0) 	{	  printout(np);	  np++;	}      update(np);         //area_check();#if CONC       update_concentration();#endif           //remesh(); //commented out for elastic boundary      //cout << "Boundary pts: " << Ls << '\n';    }#if WALLS   delete [] Xw0;   delete [] Xw0i;   delete [] Yw0;   delete [] Yw0i;   delete [] Fxw0;   delete [] Fyw0;   delete [] Vxw0;   delete [] Vyw0;#endif  return 0;}/*General functions*/int initialise(){  int i,j,s,n;  double theta,theta1;  for (i = 0; i < Lx; i++)     {      x[i] = -xlength/2.0 + i*h;         xp[i] = -xlength/2.0 + (i+0.5)*h;      //overlayed lattices    }  for (j = 0; j < Ly; j++)     {      y[j] = -ylength/2.0 + j*h;      yp[j] = -ylength/2.0 + (j+0.5)*h;    }  //vx and fx defined on (x,yp) lattice  //vy and fy defined on (xp,y) lattice  //Pressure defined on (xp,yp) lattice  if(FROMFILE)    //start from input file    {      ifstream bin,pin,win;      string temp;            bin.open("boundary.in");     //call input file "boundary.in"      s = 0;      if(bin.good())	{#if CONC	  while(bin >> X[s] >> Y[s] >> temp >> temp >> Cs[s] >> temp >> temp >> temp >> temp) s++;#else	  while(bin >> X[s] >> Y[s] >> temp >> temp >> temp >> temp >> temp) s++;#endif  	}      else	{	  cout << "Could not open file boundary.in\n";	  return 1;	}      Ls = s;      update_spacing(); //work out com            double tmag;            for(s=0;s<Ls;s++)	{	  tvx[s] = dsf_(Xt,s);   //get tangent (defined on s1 lat) 	  tvy[s] = dsf_(Yt,s);	  tmag = sqrt(tvx[s]*tvx[s]+tvy[s]*tvy[s]);	  tvx[s] = tvx[s]/tmag;       	  tvy[s] = tvy[s]/tmag;  //normalise	  nvx[s] = tvy[s];	  nvy[s] = -tvx[s];    //get normal vector on s1 lat	}            update_H();#if BULKPOL      pin.open("bulk.in");  //call bulk file bulk.in      for(i=0;i<Lx;i++)	{	  for(j=0;j<Ly;j++)	    {	      n = i*Ly+j; #if CONC	      pin >> temp >> temp >> temp >> temp >> px[n] >> py[n] >> temp >> temp >> temp >> temp >> temp;#else	      pin >> temp >> temp >> temp >> temp >> px[n] >> py[n] >> temp >> temp >> temp >> temp;#endif	    }	}#endif    }  else   //start with a circular droplet    {#if CONC      masstot = 0;#endif      double delta_s; // TESTING SOMETHING      for(s=0;s<Ls;s++)	{	  //delta_s = -2 + (rand()%5); // TESTING SOMETHING	  //cout << "Delta s " << delta_s << " "; // TESTING SOMETHING	  //cout << "s=" << s; //printing out no. of points	  theta = s*ds/R0; // don't need this but leaving in for now in case of errors	  X[s] = (s*ds) - 30;  // series of uniformly distributed points, shifted left by 30 points	  if(X[s]>=xlength/2.0) X[s]-=xlength;	  if(X[s]<-xlength/2.0) X[s]+=xlength;	  //cout << "X point=" << X[s] << endl; //TESTING SOMETHING	  Y[s] = (s*2); // y has a gradient of 2	  if(Y[s]>=ylength/2.0) Y[s]-=ylength;	  if(Y[s]<-ylength/2.0) Y[s]+=ylength;#if CONC	  Cs[s] = conc0;	  masstot += Cs[s]*ds;#endif	}      //area = M_PI*R0*R0;      //oldarea = area;      update_spacing(); //work out com      double tmag;            for(s=0;s<Ls;s++)	{	  tvx[s] = dsf_(Xt,s);   //get tangent (defined on s1 lat) 	  tvy[s] = dsf_(Yt,s);	  tmag = sqrt(tvx[s]*tvx[s]+tvy[s]*tvy[s]);	  tvx[s] = tvx[s]/tmag;       	  tvy[s] = tvy[s]/tmag;  //normalise	  nvx[s] = tvy[s];	  nvy[s] = -tvx[s];    //get normal vector on s1 lat	}            update_H();#if CONC      double g = 0.2*R0; // I'm not sure what this is?  Doesn't seem to be used...      double Ri, Havb=0;      int ih1, jh1;            for(s=0;s<Ls;s++)	{	  ih1 = Xi1(Xp[s]);          	  jh1 = Yj1(Yp[s]);	  for(i=-1;i<=2;i++)	    {	      for(j=-1;j<=2;j++)		{		  n = ip(ih1,i)*Ly + jp(jh1,j);		  Havb += H[n]*deltah(xp[ip(ih1,i)],yp[jp(jh1,j)],Xp[s],Yp[s])*h*h*ds/(xlength);		}	    }	}      cbulk0 /= Havb;      for(i=0;i<Lx;i++)	{	  for(j=0;j<Ly;j++) 	    {	      n = i*Ly + j;	      c.bulk[n] = cbulk0; 	      masstot += H[n]*c.bulk[n]*h*h;	    }	}      dmasstot = 0;#endif#if BULKPOL      for(i=0;i<Lx;i++)	{	  for(j=0;j<Ly;j++) 	    {	      n = i*Ly + j;	      if(sqrt(xp[i]*xp[i]+yp[j]*yp[j])<R0) px[n] = 1.0/sqrt(2.0);    //p defined on P lattice	      else px[n] = 0;              py[n] = 0.0;   	    }	}#endif      #if WALLS      double xh,yh;      for(i=0;i<2*Lx;i++)	{	  for(j=0;j<2*Ly;j++)	    {	      xh = -xlength/2 + (i+0.5)*0.5*h;	      yh = -ylength/2 + (j+0.5)*0.5*h;	      if(yh <= bottom_wall_position(xh) || yh >= top_wall_position(xh)) Nsw++;	    }	}      cout << "Nsw: " << Nsw << '\n';      Xw0 = new double [Nsw];      Xw0 = new double [Nsw];      Yw0 = new double [Nsw];      Yw0i = new double [Nsw];      Fxw0 = new double [Nsw];      Fyw0 = new double [Nsw];      Vxw0 = new double [Nsw];      Vyw0 = new double [Nsw];      s = 0;      for(i=0;i<2*Lx;i++)	{	  for(j=0;j<2*Ly;j++)	    {	      xh = -xlength/2 + (i+0.5)*0.5*h;	      yh = -ylength/2 + (j+0.5)*0.5*h;	      if(yh <= bottom_wall_position(xh) || yh >= top_wall_position(xh))		{		  Xw0[s] = xh;		  Yw0[s] = yh;		  Xw0i[s] = Xw0[s];		  Yw0i[s] = Yw0[s];		  s++;		}	    }	}#endif    }   return 0;}void printout(int t)         //output data{  int i, j, s, n, n1;  ofstream ofile,bfile,wfile;  stringstream fname;  double dXds;  fname << "bulk" << setfill('0') << setw(5) << t << ".txt";     //bulk file  ofile.open(fname.str().c_str());  cout << t << '\n';  if(ofile.good())    {      for (i = 0; i < Lx; i++) 	{	  for (j = 0; j < Ly; j++) 	    {	      n = i*Ly+j;   //print on P lattice 	      ofile << xp[i] << '\t' <<  yp[j] << '\t';	      ofile << x2plat(ux.bulk,n) << '\t' << y2plat(uy.bulk,n) << '\t';#if BULKPOL	      ofile << px[n] << '\t' << py[n] << '\t';#endif#if CONC	      ofile << c.bulk[n] << '\t';#endif	      ofile << P.bulk[n] << '\t'		    << x2plat(fx,n) << '\t' << y2plat(fy,n) << '\t' 		    << H[n] << '\n';	    }	  ofile << '\n';	}    }  ofile.close();  fname.str("");  fname << "boundary" << setfill('0') << setw(5) << t << ".txt";     //boundary file  bfile.open(fname.str().c_str());  if(bfile.good())    {      for(s=0;s<Ls;s++)	{	  dXds = 0.5*sqrt(dsb_(Xt,s)*dsb_(Xt,s) + dsb_(Yt,s)*dsb_(Yt,s)) + 0.5*sqrt(dsf_(Xt,s)*dsf_(Xt,s) + dsf_(Yt,s)*dsf_(Yt,s));  //stretching factor	  bfile << X[s] << '\t' << Y[s] << '\t'                 << ux.surface[s] << '\t' << uy.surface[s] << '\t';#if CONC	  bfile << 0.5*(Cs[s]+Cs[sp(s,-1)]) << '\t' << 0.5*(c.surface[s]+c.surface[sp(s,-1)]) << '\t';#endif	  bfile << Fx[s] << '\t' << Fy[s] << '\t' << dXds  << '\n';	}    }  bfile.close();#if WALLS  fname.str("");  fname << "walls" << setfill('0') << setw(5) << t << ".txt";     //boundary file  wfile.open(fname.str().c_str());  if(wfile.good())    {      for(s=0;s<Nsw;s++)	{	  wfile << Xw0[s] << '\t' << Yw0[s] << '\t' 	        << Fxw0[s] << '\t' << Fyw0[s]  << '\t'	        << Xw0i[s] << '\t' << Yw0i[s] << '\n';	}    }  wfile.close();#endif }void print_modes(void){  int i,n;  ofstream velout;	  mode_calc();  velout.open("velocity.txt", ofstream::app);double velav = 0;double Hin = 0;for(n=0;n<Lx*Ly;n++){velav += sqrt(x2plat(ux.bulk,n)*x2plat(ux.bulk,n) + y2plat(uy.bulk,n)*y2plat(uy.bulk,n))*H[n];Hin += H[n];}velav = velav/Hin;  if(velout.good())    {      velout << t/velskip << '\t' << xcomp << '\t' << ycomp << "\t" << Vxcom << '\t' << Vycom << '\t' << area << '\t' << velav;      for(i=0;i<Nmodes;i++) velout << "\t" << kmode[i] << '\t' << kmodeim[i];      velout << '\n';    }  velout.close();#if CONC  ofstream concout;  double massout=0;  for(i=0;i<Lx*Ly;i++)  {    if(H[i]<0.5) massout += H[i]*c.bulk[i]*h*h;  }  concout.open("c_modes.txt", ofstream::app);  if(concout.good())    {      concout << t/velskip << '\t' << masstot << '\t' << dmasstot << '\t' << massout;      for(i=0;i<Nmodes;i++) concout << "\t" << cmode[i] << '\t' << cmodeim[i];      concout << '\n';    }  concout.close();#endif}void old_values(void){   int i,j,n,ihp1,jhp1,np,s;  for(i=0;i<Lx;i++)    {      for(j=0;j<Ly;j++)	{	  n = i*Ly + j;	  uxold[n] = ux.bulk[n];	  uyold[n] = uy.bulk[n];	  Hold[n] = H[n];	}    }#if CONC  fill(c.surface,c.surface+Ls,0);  for(s=0;s<Ls;s++)    {      ihp1 = Xi1(Xp[s]);      jhp1 = Yj1(Yp[s]);      for(i=-1;i<=2;i++)     //nearest 4 x points (ih+i)	{	  for(j=-1;j<=2;j++)     //nearest 4 y points(jh+j)	    {	      np = ip(ihp1,i)*Ly + jp(jhp1,j);	      if(koff>0) c.surface[s] += H[np]*c.bulk[np]*deltah(xp[ip(ihp1,i)],yp[jp(jhp1,j)],Xp[s],Yp[s])*h*h;	    }	}    }#endif}/*Fluid functions*/void mode_calc(void){  int i,j,s,n;  double Xeff0,Yeff0,Reff0,theta0,Xeff1,Yeff1,Reff1,theta1,dtheta,dXds;  /***centre of mass velocity***/  Vxcom = (xcomp-xcold)/(velskip*dt);  if(Vxcom*velskip*dt > xlength/2.0) Vxcom -= xlength/(velskip*dt);  if(Vxcom*velskip*dt < -xlength/2.0) Vxcom += xlength/(velskip*dt);  Vycom = (ycomp-ycold)/(velskip*dt);  if(Vycom*velskip*dt > ylength/2.0) Vycom -= ylength/(velskip*dt);  if(Vycom*velskip*dt < -ylength/2.0) Vycom += ylength/(velskip*dt);  xcold = xcomp;  ycold = ycomp;  /***shape and conc modes***/  for(i=0;i<Nmodes;i++)   {    kmode[i] = 0;    kmodeim[i]=0;#if CONC    cmode[i] = 0;    cmodeim[i]=0;#endif  }  /***Express boundary/concentration in terms of fourier coefficients of order i. Starting at i=2 for the shape and i=1 for the concentration****/  for(s=0;s<Ls;s++)    {      Reff0 = sqrt(Xt[s]*Xt[s] + Yt[s]*Yt[s]);      theta0 = atan2(Yt[s],Xt[s]);      //comp-com gives proper com on t lattice, should be roughly 0      Reff1 = sqrt(Xt[sp(s,1)]*Xt[sp(s,1)] + Yt[sp(s,1)]*Yt[sp(s,1)]);      theta1 = atan2(Yt[sp(s,1)],Xt[sp(s,1)]);      if(theta1>theta0+M_PI) theta1 -= 2*M_PI;      if(theta1<theta0-M_PI) theta1 += 2*M_PI;      dtheta = theta1 - theta0;      for(i=0;i<Nmodes;i++)       {        kmode[i] += 0.5*(Reff0 + Reff1)*cos(0.5*(i+2.0)*(theta0+theta1))*dtheta/M_PI;        kmodeim[i] += 0.5*(Reff0 + Reff1)*sin(0.5*(i+2.0)*(theta0+theta1))*dtheta/M_PI;#if CONC        cmode[i] += Cs[s]*cos(0.5*(i+1.0)*(theta0+theta1))*dtheta/M_PI;        cmodeim[i] += Cs[s]*sin(0.5*(i+1.0)*(theta0+theta1))*dtheta/M_PI;#endif      }    }}void fourier_solve(void){  int i,j,n,qi,qj,qn;  double trigx[2*Lx],trigy[2*Ly];  double divu[Lx*Ly], divui[Lx*Ly];   //intermediate velocity divergence  complex<double> ii(0.0,1.0);  complex<double> W,V,Vqi(1.0),Wqj,uxh,uyh,Ph,D;  double Ps[Lx*Ly], Psi[Lx*Ly];   //intermediate pressure  for(i=0;i<Lx;i++)    {      for(j=0;j<Ly;j++)	{	  n = i*Ly+j;	  fxp[n] = fx[n];  //on x lattice	  fyp[n] = fy[n];  //on y lattice	  fxpi[n] = 0;	  fypi[n] = 0;	}    } c06gzc(Lx, trigx, NAGERR_DEFAULT);  //initialise trigx and trigy for FT c06gzc(Ly, trigy, NAGERR_DEFAULT); c06fuc(Lx,Ly,fxp,fxpi,trigx,trigy,NAGERR_DEFAULT);   //Fourier transform fx c06gzc(Lx, trigx, NAGERR_DEFAULT);  //re-initialise trigx and trigy c06gzc(Ly, trigy, NAGERR_DEFAULT); c06fuc(Lx,Ly,fyp,fypi,trigx,trigy,NAGERR_DEFAULT);    //Fourier transform fy V = exp(-ii*2.0*M_PI/((double) Lx)); W = exp(-ii*2.0*M_PI/((double) Ly)); for(qi=0;qi<Lx;qi++)   {     Wqj = 1.0;     for(qj=0;qj<Ly;qj++)       {	 qn = qi*Ly + qj;	 D = (-2.0 + Vqi + 1.0/Vqi - 2.0 + Wqj + 1.0/Wqj)/(h*h);  //delsq operator	 if(D!=(0.0,0.0)) uxh = -(fxp[qn] + fxpi[qn]*ii)/(eta*D);	 else uxh = 0.0;	 if(D!=(0.0,0.0)) uyh = -(fyp[qn] + fypi[qn]*ii)/(eta*D);	 else uyh = 0.0;	 uxp[qn] = uxh.real();	 uxpi[qn] =  uxh.imag();   //to store fourier transform of ux	 ux.bulk[qn] = uxp[qn];	 uxi[qn] = uxpi[qn];      //to be fourier transformed back	 uyp[qn] = uyh.real();	 uypi[qn] =  uyh.imag();   //to store fourier transform of uy	 uy.bulk[qn] = uyp[qn];	 uyi[qn] = uypi[qn];      //to be fourier transformed back	 Wqj *= W;    //V^qj       }     Vqi *= V;   //V^qi   } c06gzc(Lx, trigx, NAGERR_DEFAULT);   //re-initialise trigx and trigy c06gzc(Ly, trigy, NAGERR_DEFAULT); c06gcc(Lx*Ly, uxi, NAGERR_DEFAULT);   //take conjugate of imag part c06fuc(Lx, Ly, ux.bulk, uxi, trigx, trigy, NAGERR_DEFAULT);   //Fourier transform back ux c06gcc(Lx*Ly, uxi, NAGERR_DEFAULT);   //take conjugate of imag part c06gzc(Lx, trigx, NAGERR_DEFAULT);    //re-initialise trigx and trigy c06gzc(Ly, trigy, NAGERR_DEFAULT); c06gcc(Lx*Ly, uyi, NAGERR_DEFAULT);   //take conjugate of imag part c06fuc(Lx, Ly, uy.bulk, uyi, trigx, trigy, NAGERR_DEFAULT);   //Fourier transform back uy c06gcc(Lx*Ly, uyi, NAGERR_DEFAULT);  //take conjugate of imag part  //ux and uy is now intermediate velocity //work out divergence of u  for(i=0;i<Lx;i++)   {     for(j=0;j<Ly;j++)       {	 n = i*Ly+j;	 divu[n] = dxf_(ux.bulk,i,j) + dyf_(uy.bulk,i,j);  //div(u) on P lattice	 divui[n] = 0.0;   //imag part       }   } c06gzc(Lx, trigx, NAGERR_DEFAULT);  //re-initialise trigx and trigy c06gzc(Ly, trigy, NAGERR_DEFAULT); c06fuc(Lx,Ly,divu,divui,trigx,trigy,NAGERR_DEFAULT);    //Fourier transform divu V = exp(-ii*2.0*M_PI/((double) Lx)); W = exp(-ii*2.0*M_PI/((double) Ly)); for(qi=0;qi<Lx;qi++)   {     Wqj = 1.0;     for(qj=0;qj<Ly;qj++)       {	 qn = qi*Ly + qj;	 D = (-2.0 + Vqi + 1.0/Vqi - 2.0 + Wqj + 1.0/Wqj)/(h*h);  //delsq operator	 if(D!=(0.0,0.0)) Ph = (divu[qn] + divui[qn]*ii)/(D);	 else Ph = 0.0;	 Ps[qn] = Ph.real();	 Psi[qn] =  Ph.imag();   //to be fourier tranformed back	 Wqj *= W;    //V^qj       }     Vqi *= V;   //V^qi   } c06gzc(Lx, trigx, NAGERR_DEFAULT);   //re-initialise trigx and trigy c06gzc(Ly, trigy, NAGERR_DEFAULT); c06gcc(Lx*Ly, Psi, NAGERR_DEFAULT);   //take conjugate of imag part c06fuc(Lx, Ly, Ps, Psi, trigx, trigy, NAGERR_DEFAULT);   //Fourier transform back P c06gcc(Lx*Ly, Psi, NAGERR_DEFAULT);   //take conjugate of imag part //now P is intermediate pressure for(i=0;i<Lx;i++)   {     for(j=0;j<Ly;j++)       {	 n = i*Ly+j;	 ux.bulk[n] -= dxb_(Ps,i,j);   //on x lattice	 uy.bulk[n] -= dyb_(Ps,i,j);   //on y lattice	 P.bulk[n] = -eta*(dx2_(Ps,i,j) + dy2_(Ps,i,j));   //on p lattice       }   }}void update(int t){  //4th order runge kutta  int i,j,n,s;#if BULKPOL    double pxold[Lx*Ly], pyold[Lx*Ly],k1x[Lx*Ly],k2x[Lx*Ly],k3x[Lx*Ly],k4x[Lx*Ly],k1y[Lx*Ly],k2y[Lx*Ly],k3y[Lx*Ly],k4y[Lx*Ly];#endif  double *Xold, *Yold, *k1xb, *k2xb, *k3xb, *k4xb, *k1yb, *k2yb, *k3yb, *k4yb;#if WALLSdouble *Xw0old, *Yw0old, *k1xw0b, *k2xw0b, *k3xw0b, *k4xw0b, *k1yw0b, *k2yw0b, *k3yw0b, *k4yw0b; Xw0old = new double [Nsw]; Yw0old = new double [Nsw]; k1xw0b = new double [Nsw]; k2xw0b = new double [Nsw]; k3xw0b = new double [Nsw]; k4xw0b = new double [Nsw]; k1yw0b = new double [Nsw]; k2yw0b = new double [Nsw]; k3yw0b = new double [Nsw]; k4yw0b = new double [Nsw];#endif Xold = new double [Ls]; Yold = new double [Ls]; k1xb = new double [Ls]; k1yb = new double [Ls]; k2xb = new double [Ls]; k2yb = new double [Ls]; k3xb = new double [Ls]; k3yb = new double [Ls]; k4xb = new double [Ls]; k4yb = new double [Ls];  for(s=0;s<Ls;s++)    {      Xold[s] = X[s];      Yold[s] = Y[s];      Xpold[s] = Xp[s];      Ypold[s] = Yp[s];      Xtold[s] = Xt[s];      Ytold[s] = Yt[s];      k1xb[s] = dt*ux.surface[s];      k1yb[s] = dt*uy.surface[s];      X[s] += k1xb[s]/2;      while(X[s]>xlength/2) X[s]-=xlength;       while(X[s]<-xlength/2) X[s]+=xlength;  //periodic bcs      Y[s] += k1yb[s]/2;      while(Y[s]>ylength/2) Y[s]-=ylength;       while(Y[s]<-ylength/2) Y[s]+=ylength;  //periodic bcs    }#if BULKPOL  for(i=0;i<Lx;i++)       {      for(j=0;j<Ly;j++)	{	  n = i*Ly+j;	  pxold[n] = px[n];	  pyold[n] = py[n];	  k1x[n] = dt*mux[n];	  k1y[n] = dt*muy[n];	  px[n] += k1x[n]/2;	  py[n] += k1y[n]/2;	}    }#endif#if WALLS  for(s=0;s<Nsw;s++)    {      Xw0old[s] = Xw0[s];      Yw0old[s] = Yw0[s];      k1xw0b[s] = dt*Vxw0[s];      k1yw0b[s] = dt*Vyw0[s];      Xw0[s] += k1xw0b[s]/2;      while(Xw0[s]>xlength/2) Xw0[s]-=xlength;       while(Xw0[s]<-xlength/2) Xw0[s]+=xlength;  //periodic bcs      Yw0[s] += k1yw0b[s]/2;      while(Yw0[s]>ylength/2) Yw0[s]-=ylength;       while(Yw0[s]<-ylength/2) Yw0[s]+=ylength;  //periodic bcs    }#endif  update_spacing(); boundary_force();#if BULKPOL calc_force();#endif fourier_solve();#if BULKPOL pol_calc();#endif boundary_vel(); for(s=0;s<Ls;s++)   {     k2xb[s] = dt*ux.surface[s];     k2yb[s] = dt*uy.surface[s];     X[s] = Xold[s] + k2xb[s]/2;     while(X[s]>xlength/2) X[s]-=xlength;      while(X[s]<-xlength/2) X[s]+=xlength;  //periodic bcs     Y[s] = Yold[s] + k2yb[s]/2;     while(Y[s]>ylength/2) Y[s]-=ylength;      while(Y[s]<-ylength/2) Y[s]+=ylength;  //periodic bcs   } #if BULKPOL for(i=0;i<Lx;i++)      {     for(j=0;j<Ly;j++)       {	 n = i*Ly+j;	 k2x[n] = dt*mux[n];	 k2y[n] = dt*muy[n];	 px[n] = pxold[n] + k2x[n]/2;	 py[n] = pyold[n] + k2y[n]/2;       }   }#endif#if WALLS  for(s=0;s<Nsw;s++)    {      k2xw0b[s] = dt*Vxw0[s];      k2yw0b[s] = dt*Vyw0[s];      Xw0[s] = Xw0old[s] + k2xw0b[s]/2;      while(Xw0[s]>xlength/2) Xw0[s]-=xlength;       while(Xw0[s]<-xlength/2) Xw0[s]+=xlength;  //periodic bcs      Yw0[s] = Yw0old[s] + k2yw0b[s]/2;      while(Yw0[s]>ylength/2) Yw0[s]-=ylength;       while(Yw0[s]<-ylength/2) Yw0[s]+=ylength;  //periodic bcs    }#endif update_spacing(); boundary_force();#if BULKPOL calc_force();#endif fourier_solve();#if BULKPOL pol_calc();#endif boundary_vel(); for(s=0;s<Ls;s++)   {     k3xb[s] = dt*ux.surface[s];     k3yb[s] = dt*uy.surface[s];     X[s] = Xold[s] + k3xb[s];     while(X[s]>xlength/2) X[s]-=xlength;      while(X[s]<-xlength/2) X[s]+=xlength;  //periodic bcs     Y[s] = Yold[s] + k3yb[s];     while(Y[s]>ylength/2) Y[s]-=ylength;      while(Y[s]<-ylength/2) Y[s]+=ylength;  //periodic bcs   } #if BULKPOL for(i=0;i<Lx;i++)      {     for(j=0;j<Ly;j++)       {	 n = i*Ly+j;	 k3x[n] = dt*mux[n];	 k3y[n] = dt*muy[n];	 px[n] = pxold[n] + k3x[n];	 py[n] = pyold[n] + k3y[n];       }   }#endif#if WALLS  for(s=0;s<Nsw;s++)    {      k3xw0b[s] = dt*Vxw0[s];      k3yw0b[s] = dt*Vyw0[s];      Xw0[s] = Xw0old[s] + k3xw0b[s];      while(Xw0[s]>xlength/2) Xw0[s]-=xlength;       while(Xw0[s]<-xlength/2) Xw0[s]+=xlength;  //periodic bcs      Yw0[s] = Yw0old[s] + k3yw0b[s];      while(Yw0[s]>ylength/2) Yw0[s]-=ylength;       while(Yw0[s]<-ylength/2) Yw0[s]+=ylength;  //periodic bcs    }#endif  update_spacing(); boundary_force();#if BULKPOL calc_force();#endif fourier_solve();#if BULKPOL pol_calc();#endif boundary_vel(); for(s=0;s<Ls;s++)   {     k4xb[s] = dt*ux.surface[s];     k4yb[s] = dt*uy.surface[s];     X[s] = Xold[s] + k1xb[s]/6.0 + k2xb[s]/3.0 + k3xb[s]/3.0 + k4xb[s]/6.0;     while(X[s]>xlength/2) X[s]-=xlength;      while(X[s]<-xlength/2) X[s]+=xlength;  //periodic bcs     Y[s] = Yold[s] + k1yb[s]/6.0 + k2yb[s]/3.0 + k3yb[s]/3.0 + k4yb[s]/6.0;     while(Y[s]>ylength/2) Y[s]-=ylength;      while(Y[s]<-ylength/2) Y[s]+=ylength;  //periodic bcs   } #if BULKPOL for(i=0;i<Lx;i++)      {     for(j=0;j<Ly;j++)       {	 n = i*Ly+j;	 k4x[n] = dt*mux[n];	 k4y[n] = dt*muy[n];	 px[n] = pxold[n] + k1x[n]/6.0 + k2x[n]/3.0 + k3x[n]/3.0 + k4x[n]/6.0;	 py[n] = pyold[n] + k1y[n]/6.0 + k2y[n]/3.0 + k3y[n]/3.0 + k4y[n]/6.0;       }   }#endif#if WALLS  for(s=0;s<Nsw;s++)    {      k4xw0b[s] = dt*Vxw0[s];      k4yw0b[s] = dt*Vyw0[s];      Xw0[s] = Xw0old[s] + k1xw0b[s]/6.0 + k2xw0b[s]/3.0 + k3xw0b[s]/3.0 + k4xw0b[s]/6.0;      while(Xw0[s]>xlength/2) Xw0[s]-=xlength;       while(Xw0[s]<-xlength/2) Xw0[s]+=xlength;  //periodic bcs      Yw0[s] = Yw0old[s] + k1yw0b[s]/6.0 + k2yw0b[s]/3.0 + k3yw0b[s]/3.0 + k4yw0b[s]/6.0;      while(Yw0[s]>ylength/2) Yw0[s]-=ylength;       while(Yw0[s]<-ylength/2) Yw0[s]+=ylength;  //periodic bcs    }  delete [] Xw0old;  delete [] Yw0old;  delete [] k1xw0b;  delete [] k1yw0b;  delete [] k2xw0b;  delete [] k2yw0b;  delete [] k3xw0b;  delete [] k3yw0b;  delete [] k4xw0b;  delete [] k4yw0b;#endif  update_spacing(); update_H(); delete [] Xold; delete [] Yold; delete [] k1xb; delete [] k1yb; delete [] k2xb; delete [] k2yb; delete [] k3xb; delete [] k3yb; delete [] k4xb; delete [] k4yb;}/*******Active gel functions*********/#if BULKPOLvoid calc_force(void){  int i,j,n;  double dxpx,dxpy,dypx,dypy,dxHp,dyHp,DHmag;  double dxsxx,dxsyx,dysxy,dysyy,hxx,hxy,hyx,hyy,psq,pxx,pxy,pyx,pyy;  double f0[Lx*Ly], mupartx[Lx*Ly], muparty[Lx*Ly];    //free energy  for(i=0;i<Lx;i++)    {      for(j=0;j<Ly;j++)	{	  n = i*Ly + j;	  dxHp = 0.5*(dxH[n]+dxH[ip(i,1)*Ly+j]);	  dyHp = 0.5*(dyH[n]+dyH[i*Ly+jp(j,1)]);  //on P lat	  DHmag = sqrt(dxHp*dxHp + dyHp*dyHp);	  hx[n] = 0;	  hy[n] = 0;	  sxx[n] = 0;	  sxy[n] = 0;	  syx[n] = 0;	  syy[n] = 0;	  f0[n] = 0;	  if(DHmag>0) 	    {	      mupartx[n] = (px[n] + dxHp/DHmag)*(px[n]*dxHp + py[n]*dyHp + DHmag);	      muparty[n] = (py[n] + dyHp/DHmag)*(px[n]*dxHp + py[n]*dyHp + DHmag);	    }	  else	    {	      mupartx[n] = (px[n])*(px[n]*dxHp + py[n]*dyHp + DHmag);	      muparty[n] = (py[n])*(px[n]*dxHp + py[n]*dyHp + DHmag);	    }	}    } for(i=0;i<Lx;i++)    {      for(j=0;j<Ly;j++)	{	  n = i*Ly+j;	  /**on P lattice**/	  psq = px[n]*px[n] + py[n]*py[n];	  dxpx = 0.5*(dxb_(px,i,j) + dxf_(px,i,j));	  dxpy = 0.5*(dxb_(py,i,j) + dxf_(py,i,j));	  dypx = 0.5*(dyb_(px,i,j) + dyf_(px,i,j));	  dypy = 0.5*(dyb_(py,i,j) + dyf_(py,i,j));	  dxHp = 0.5*(dxH[n]+dxH[ip(i,1)*Ly+j]);	  dyHp = 0.5*(dyH[n]+dyH[i*Ly+jp(j,1)]);   //on P lat 	  DHmag = sqrt(dxHp*dxHp + dyHp*dyHp);	  hx[n] += ( /*elastic energy*/ K*(dx2_(px,i,j) + dy2_(px,i,j)) /*IN transition*/ - K*c0*px[n]*(psq-H[n]) /*anchoring*/ - W1*dxHp*(px[n]*dxHp + py[n]*dyHp + DHmag) );	  hy[n] += ( /*elastic energy*/ K*(dx2_(py,i,j) + dy2_(py,i,j)) /*IN transition*/ - K*c0*py[n]*(psq-H[n]) /*anchoring*/ - W1*dyHp*(px[n]*dxHp + py[n]*dyHp + DHmag) );	  f0[n] += K*(dxpx*dxpx + dxpy*dxpy + dypx*dypx + dypy*dypy)/2.0 + K*c0*psq*(psq-2*H[n])/4.0 + W1*(px[n]*dxHp + py[n]*dyHp + DHmag)*(px[n]*dxHp + py[n]*dyHp + DHmag)/2.0;	  /**Symmetric part of lc stress**/	  sxx[n] += nu*px[n]*hx[n] - K*(dxpx*dxpx + dxpy*dxpy);	  sxy[n] += nu*(px[n]*hy[n] + py[n]*hx[n])/2.0 - K*(dxpx*dypx + dxpy*dypy);	  syx[n] += nu*(px[n]*hy[n] + py[n]*hx[n])/2.0 - K*(dxpx*dypx + dxpy*dypy);	  syy[n] += nu*py[n]*hy[n] - K*(dypx*dypx + dypy*dypy);	  /**Anti-symmetric part of lc stress**/	  sxy[n] += (px[n]*hy[n] - py[n]*hx[n])/2.0;	  syx[n] += -(px[n]*hy[n] - py[n]*hx[n])/2.0;	  /**Active stress**/	  sxx[n] += -Zeta*H[n]*(px[n]*px[n]-0.5);	  sxy[n] += -Zeta*H[n]*px[n]*py[n];	  syx[n] += -Zeta*H[n]*px[n]*py[n];	  syy[n] += -Zeta*H[n]*(py[n]*py[n]-0.5);	  /**Interface stress**/	  sxx[n] += f0[n] + K*c0*H[n]*psq/2.0 + W1*0.5*H[n]*(dxf_(mupartx,i,j) + dxb_(mupartx,i,j) + dyf_(muparty,i,j) + dyb_(muparty,i,j)) - W1*mupartx[n]*dxHp;	  sxy[n] += -W1*muparty[n]*dxHp;	  syx[n] += -W1*mupartx[n]*dyHp;	  syy[n] += f0[n] + K*c0*H[n]*psq/2.0 + W1*0.5*H[n]*(dxf_(mupartx,i,j) + dxb_(mupartx,i,j) + dyf_(muparty,i,j) + dyb_(muparty,i,j)) - W1*muparty[n]*dyHp;	}    } for(i=0;i<Lx;i++)    {      for(j=0;j<Ly;j++)	{	  n = i*Ly + j;	  /*****These need to be on x lattice******/	  dxsxx = dxb_(sxx, i, j);	  dysxy = (dyf_(sxy, i, j) + dyb_(sxy, i, j) + dyf_(sxy, ip(i,-1), j) + dyb_(sxy, ip(i,-1), j))/4.0; 	  /*****These need to be on y lattice******/	  dxsyx = (dxf_(syx, i, j) + dxb_(syx, i, j) + dxf_(syx, i, jp(j,-1)) + dxb_(syx, i, jp(j,-1)))/4.0; 	  dysyy = dyb_(syy, i, j);	  /***active liq crys forces*****/	  fx[n] += dxsxx + dysxy;	  fy[n] += dxsyx + dysyy;	}    }}void pol_calc(void){  double x,y,dxux,dxuy,dyux,dyuy,dxpx,dxpy,dypx,dypy;  int i,j,n;  for(i = 0 ; i < Lx ; i++)      {     for(j = 0 ; j < Ly ; j++)       {	  n = i*Ly+j;	  dxux = dxf_(ux.bulk,i,j);  //puts on p lattice	  dxuy = (dxf_(uy.bulk,i,j) + dxb_(uy.bulk,i,j) + dxf_(uy.bulk,i,jp(j,1)) + dxb_(uy.bulk,i,jp(j,1)))/4.0;   //interpolate to p lattice	  dyux = (dyf_(ux.bulk,i,j) + dyb_(ux.bulk,i,j) + dyf_(ux.bulk,ip(i,1),j) + dyb_(ux.bulk,ip(i,1),j))/4.0;  //interpolate to p lattice	  dyuy = dyf_(uy.bulk,i,j);  //puts on p lattice	  dxpx = 0.5*(dxf_(px,i,j) + dxb_(px,i,j));	  dxpy = 0.5*(dxf_(py,i,j) + dxb_(py,i,j));	  dypx = 0.5*(dyf_(px,i,j) + dyb_(px,i,j));	  dypy = 0.5*(dyf_(py,i,j) + dyb_(py,i,j));	  mux[n] = -vdelx(px,x2plat(ux.bulk,n),i,j) - vdely(px,y2plat(uy.bulk,n),i,j) - (dxuy-dyux)*py[n]/2.0 - nu*(dxux*px[n] + (dxuy + dyux)*py[n]/2.0) + hx[n]/Gamma;	  muy[n] = -vdelx(py,x2plat(ux.bulk,n),i,j) - vdely(py,y2plat(uy.bulk,n),i,j) + (dxuy-dyux)*px[n]/2.0 - nu*(dyuy*py[n] + (dxuy + dyux)*px[n]/2.0) + hy[n]/Gamma;	}    }}#endif#if CONCvoid update_concentration(void){  //Crank-Nicholson  int s,s1,ih1,jh1,i,j,n;  double dXs,dXsold,dXsp,dXspold,dXsm,dXsmold;  double *A;      double *b;  int *ipiv;  double *cp;  double rcond, errbnd;  int pda = Ls;  int nrhs = 1;  int pdb = 1;  A = NAG_ALLOC(Ls*Ls, double);  b = NAG_ALLOC(Ls, double);  ipiv = NAG_ALLOC(Ls, int);  cp = NAG_ALLOC(Ls, double);  fill(A,A+Ls*Ls,0);  fill(ipiv,ipiv+Ls,0);  fill(cp,cp+Ls,0);  for(s=0;s<Ls;s++)    {      ih1 = Xi1(Xp[s]);        //nearest x point down Plat      jh1 = Yj1(Yp[s]);        //nearest y point down Plat      for(i=-1;i<=2;i++)     //nearest 4 x points (ih+i)	{	  for(j=-1;j<=2;j++)     //nearest 4 y points(jh+j)	    {	      n = ip(ih1,i)*Ly + jp(jh1,j);	      if(koff>0) cp[s] += H[n]*c.bulk[n]*deltah(xp[ip(ih1,i)],yp[jp(jh1,j)],Xp[s],Yp[s])*h*h;	    }	}    }  for(s=0;s<Ls;s++)    {      dXs = sqrt(dsf_(Xt,s)*dsf_(Xt,s) + dsf_(Yt,s)*dsf_(Yt,s));  //stretching factor at s on s1 lattice at time n+1      dXsold = sqrt(dsf_(Xtold,s)*dsf_(Xtold,s) + dsf_(Ytold,s)*dsf_(Ytold,s));  //stretching factor at s on s1 lattice at time n      dXsp = 0.5*(sqrt(dsf_(Xt,sp(s,1))*dsf_(Xt,sp(s,1)) + dsf_(Yt,sp(s,1))*dsf_(Yt,sp(s,1))) + dXs);  //stretching factor at s+1 on s lattice at time n+1      dXspold = 0.5*(sqrt(dsf_(Xtold,sp(s,1))*dsf_(Xtold,sp(s,1)) + dsf_(Ytold,sp(s,1))*dsf_(Ytold,sp(s,1))) + dXsold);  //stretching factor at s+1 on s lattice at time n      dXsm = 0.5*(sqrt(dsf_(Xt,sp(s,-1))*dsf_(Xt,sp(s,-1)) + dsf_(Yt,sp(s,-1))*dsf_(Yt,sp(s,-1))) + dXs);  //stretching factor at s-1 on s lattice at time n+1      dXsmold = 0.5*(sqrt(dsf_(Xtold,sp(s,-1))*dsf_(Xtold,sp(s,-1)) + dsf_(Ytold,sp(s,-1))*dsf_(Ytold,sp(s,-1))) + dXsold);  //stretching factor at s-1 on s lattice at time n      A[s*(Ls+1)] = dXs + dt*Df*(1/dXsp + 1/dXsm)/(2*ds*ds) + 0.5*dt*koff*dXs;      //diagonal element      A[s*Ls + sp(s,1)] = -dt*Df/(2*ds*ds*dXsp);     //s+1 coeff      A[s*Ls + sp(s,-1)] = -dt*Df/(2*ds*ds*dXsm);     //s-1 coeff      b[s] = Cs[s]*dXsold + dt*Df*((Cs[sp(s,1)] - Cs[s])/dXspold - (Cs[s] - Cs[sp(s,-1)])/dXsmold)/(2*ds*ds) + 0.5*dt*kon*(cp[s]*dXs + c.surface[s]*dXsold) - 0.5*dt*koff*Cs[s]*dXsold;    }  f04bac(Nag_RowMajor, Ls, nrhs, A, pda, ipiv, b, pdb, &rcond, &errbnd, NAGERR_DEFAULT);    double newlength=0;  double Q[Lx*Ly];  double Csold;  int ih1old,jh1old,nold;  double oldtot=masstot;  masstot=0;    fill(Q,Q+Lx*Ly,0.);    for(s=0;s<Ls;s++)    {      dXs = sqrt(dsf_(Xt,s)*dsf_(Xt,s) + dsf_(Yt,s)*dsf_(Yt,s));  //stretching factor at s on s1 lattice at time n+1      dXsold = sqrt(dsf_(Xtold,s)*dsf_(Xtold,s) + dsf_(Ytold,s)*dsf_(Ytold,s));  //stretching factor at s on s1 lattice at time n      dXsp = 0.5*(sqrt(dsf_(Xt,sp(s,1))*dsf_(Xt,sp(s,1)) + dsf_(Yt,sp(s,1))*dsf_(Yt,sp(s,1))) + dXs);  //stretching factor at s+1 on s lattice at time n+1      dXsm = 0.5*(sqrt(dsf_(Xt,sp(s,-1))*dsf_(Xt,sp(s,-1)) + dsf_(Yt,sp(s,-1))*dsf_(Yt,sp(s,-1))) + dXs);  //stretching factor at s-1 on s lattice at time n+1      masstot+=b[s]*dXs*ds;      newlength+=dXs*ds;      Csold = Cs[s];      Cs[s] = b[s];      //update conc      if(koff>0)	{	  ih1 = Xi1(Xp[s]);        //nearest x point down	  jh1 = Yj1(Yp[s]);        //nearest y point down	  ih1old = Xi1(Xpold[s]);        //nearest x point down	  jh1old = Yj1(Ypold[s]);        //nearest y point down	  for(i=-1;i<=2;i++)     //nearest 4 x points (ih+i)	    {	      for(j=-1;j<=2;j++)     //nearest 4 y points(jh+j)		{		  //distribute binding condition to fluid  		  n = ip(ih1,i)*Ly + jp(jh1,j);		  nold = ip(ih1old,i)*Ly + jp(jh1old,j);		  Q[n] += 0.5*(kon*cp[s] - koff*Cs[s])*dXs*deltah(xp[ip(ih1,i)],yp[jp(jh1,j)],Xp[s],Yp[s])*ds;		  Q[nold] += 0.5*(kon*c.surface[s] - koff*Csold)*dXsold*deltah(xp[ip(ih1old,i)],yp[jp(jh1old,j)],Xpold[s],Ypold[s])*ds;		}	    }	}    }  NAG_FREE(A);  NAG_FREE(b);  NAG_FREE(ipiv);    if(koff>0)    {      NagError fail;      int lfill=0;      double tol = 1E-15;        int ni1, nj1, nim1,njm1;      int dim = Lx*Ly;      int NZ = 5*Lx*Ly;  //number of non-zero elements      double *bb, *Ab;      Integer *Irn, *Icn, *istr, *idiag, *ipivp, *ipivq;      int npivm, NZC;      int m = 10;      int maxitn = 1000;      int itn;      double rnorm;      Nag_Sparse_Comm comm;      Ab = NAG_ALLOC(NZ, double);      bb = NAG_ALLOC(dim, double);      Irn = NAG_ALLOC(NZ, Integer);      Icn = NAG_ALLOC(NZ, Integer);      istr = NAG_ALLOC(dim+1, Integer);      idiag = NAG_ALLOC(dim, Integer);      ipivp = NAG_ALLOC(dim, Integer);      ipivq = NAG_ALLOC(dim, Integer);            do      {        INIT_FAIL(fail);        Ab = NAG_REALLOC(Ab, NZ, double);        Irn = NAG_REALLOC(Irn, NZ, Integer);        Icn = NAG_REALLOC(Icn, NZ, Integer);         for(i=0; i<Lx; i++)  	  {	  for(j=0; j<Ly; j++)	    {	      n = i*Ly + j;	      ni1 = ip(i,1)*Ly + j;	      nj1 = i*Ly + jp(j,1);	      nim1 = ip(i,-1)*Ly + j;	      njm1 = i*Ly + jp(j,-1);	      Ab[5*n+2] = H[n] + dt*(((ux.bulk[ni1] + uy.bulk[nj1] - ux.bulk[n] - uy.bulk[n])*H[n] + ux.bulk[ni1]*H[ni1] + uy.bulk[nj1]*H[nj1] - ux.bulk[n]*H[nim1] - uy.bulk[n]*H[njm1]) /(8*h) + Dfb*(H[ni1] + H[nj1] + 4*H[n] + H[nim1] + H[njm1])/(4*h*h)); 	      Irn[5*n+2] = n+1;   //diagonal element	      Icn[5*n+2] = n+1;	      Ab[5*n+3] = dt*(H[ni1] + H[n])*(ux.bulk[ni1]/(8*h) - Dfb/(4*h*h));  //adjacent elements 	      Irn[5*n+3] = n+1;	      Icn[5*n+3] = ni1+1; 	      Ab[5*n+1] = -dt*(H[nim1] + H[n])*(ux.bulk[n]/(8*h) + Dfb/(4*h*h));	      Irn[5*n+1] = n+1;	      Icn[5*n+1] = nim1+1;	      Ab[5*n+4] = dt*(H[nj1] + H[n])*(uy.bulk[nj1]/(8*h) - Dfb/(4*h*h));	      Irn[5*n+4] = n+1;	      Icn[5*n+4] = nj1+1;	      Ab[5*n] = -dt*(H[njm1] + H[n])*(uy.bulk[n]/(8*h) + Dfb/(4*h*h)); 	      Irn[5*n] = n+1;	      Icn[5*n] = njm1+1;	      bb[n] = c.bulk[n]*Hold[n] - dt*(Q[n] + (uxold[ni1]*(Hold[ni1]+Hold[n])*(c.bulk[ni1] + c.bulk[n]) - uxold[n]*(Hold[n]+Hold[nim1])*(c.bulk[n]+c.bulk[nim1]) + uyold[nj1]*(Hold[nj1]+Hold[n])*(c.bulk[nj1] + c.bulk[n]) - uyold[n]*(Hold[n]+Hold[njm1])*(c.bulk[n]+c.bulk[njm1]))/(8*h) - Dfb*((Hold[ni1]+ Hold[n])*(c.bulk[ni1] - c.bulk[n]) - (Hold[n] + Hold[nim1])*(c.bulk[n] - c.bulk[nim1]) + (Hold[nj1]+ Hold[n])*(c.bulk[nj1] - c.bulk[n]) - (Hold[n] + Hold[njm1])*(c.bulk[n] - c.bulk[njm1])) /(4*h*h));	    }	}        int lu = 2*NZ;             f11zac(Lx*Ly,&NZ,Ab,Irn,Icn,Nag_SparseNsym_FailDups,Nag_SparseNsym_KeepZeros,istr,NAGERR_DEFAULT); //sort        Ab = NAG_REALLOC(Ab, lu, double);        Irn = NAG_REALLOC(Irn, lu, Integer);        Icn = NAG_REALLOC(Icn, lu, Integer);        f11dac(dim,NZ,&Ab,&lu,&Irn,&Icn,lfill,tol,Nag_SparseNsym_CompletePiv,Nag_SparseNsym_ModFact,ipivp,ipivq,istr,idiag,&NZC,&npivm,NAGERR_DEFAULT);   //factorise          f11dcc(Nag_SparseNsym_RGMRES,dim,NZ,Ab,lu,Irn,Icn,ipivp,ipivq,istr,idiag,bb,m,tol,maxitn,c.bulk,&rnorm,&itn,&comm,&fail);  //solve        tol = tol*10;        lfill += 5;        if(fail.code != NE_NOERROR) cout << "f11dcc fail code: " << fail.code << '\n';      } while(fail.code != NE_NOERROR);      for(i=0; i<Lx; i++)	{	  for(j=0; j<Ly; j++)	    {	      n = i*Ly + j;	      ni1 = ip(i,1)*Ly + j;	      nj1 = i*Ly + jp(j,1);	      nim1 = ip(i,-1)*Ly + j;	      njm1 = i*Ly + jp(j,-1);	      masstot += H[n]*c.bulk[n]*h*h;             }	}               NAG_FREE(Ab);      NAG_FREE(bb);      NAG_FREE(Irn);      NAG_FREE(Icn);      NAG_FREE(istr);      NAG_FREE(idiag);      NAG_FREE(ipivp);      NAG_FREE(ipivq);    }  dmasstot = masstot-oldtot;  NAG_FREE(cp);}#endifvoid update_H(void){  int i,j,n,qi,qj,qn,ih,ih1,jh,jh1,s,nx,ny;  double trigx[2*Lx],trigy[2*Ly],nxc,nyc,dXds;  complex<double> ii(0.0,1.0);  complex<double> W,V,Vqi(1.0),Wqj,D,Gh;  double G[Lx*Ly], Gi[Lx*Ly], Hi[Lx*Ly];    for(i=0;i<Lx;i++)    {      for(j=0;j<Ly;j++)	{ 	  n = i*Ly + j;	  dxH[n] = 0;	  dyH[n] = 0;	}    }    for(s=0;s<Ls;s++)    {       ih = Xi(Xp[s]);        //nearest x point down      jh = Yj(Yp[s]);        //nearest y point down      ih1 = Xi1(Xp[s]);        //nearest x point down      jh1 = Yj1(Yp[s]);        //nearest y point down      for(i=-1;i<=2;i++)     //nearest 4 x points (ih+i)	{	  for(j=-1;j<=2;j++)     //nearest 4 y points(jh+j)	    {	      //distribute derivative of H to fluid  	      nx = ip(ih,i)*Ly + jp(jh1,j);	      ny = ip(ih1,i)*Ly + jp(jh,j);	      dXds = sqrt(dsf_(Xt,s)*dsf_(Xt,s) + dsf_(Yt,s)*dsf_(Yt,s));  //stretching factor at s+1/2	      dxH[nx] += -nvx[s]*deltah(x[ip(ih,i)],yp[jp(jh1,j)],Xp[s],Yp[s])*dXds*ds;  //xlat	      dyH[ny] += -nvy[s]*deltah(xp[ip(ih1,i)],y[jp(jh,j)],Xp[s],Yp[s])*dXds*ds;  //ylat	    }	}    }    /**Solves the equation Del^2H = Del.DelH**/  for(i=0;i<Lx;i++)    {      for(j=0;j<Ly;j++)	{	  n = i*Ly + j;	  G[n] = dxf_(dxH,i,j) + dyf_(dyH,i,j);   //RHS Del^2 H on P lat	  Gi[n] = 0;  //imag part	}    }  c06gzc(Lx, trigx, NAGERR_DEFAULT);  //initialise trigx and trigy  c06gzc(Ly, trigy, NAGERR_DEFAULT);  c06fuc(Lx,Ly,G,Gi,trigx,trigy,NAGERR_DEFAULT);   //Fourier transform fx  V = exp(-ii*2.0*M_PI/((double) Lx));  W = exp(-ii*2.0*M_PI/((double) Ly));  for(qi=0;qi<Lx;qi++)    {      Wqj = 1.0;      for(qj=0;qj<Ly;qj++)	{	  qn = qi*Ly + qj;	  D = (-4.0 + Vqi + 1.0/Vqi + Wqj + 1.0/Wqj)/(h*h);  //delsq operator	  if(D!=(0.0,0.0)) Gh = (G[qn] + Gi[qn]*ii)/D;	  else Gh = 0.0;	  H[qn] = Gh.real(); 	  Hi[qn] = Gh.imag(); 	  Wqj *= W;    //V^qj       }     Vqi *= V;   //V^qi   }   c06gzc(Lx, trigx, NAGERR_DEFAULT);   //re-initialise trigx and trigy c06gzc(Ly, trigy, NAGERR_DEFAULT); c06gcc(Lx*Ly, Hi, NAGERR_DEFAULT);   //take conjugate of imag part c06fuc(Lx, Ly, H, Hi, trigx, trigy, NAGERR_DEFAULT);   //Fourier transform back ux c06gcc(Lx*Ly, Hi, NAGERR_DEFAULT);   //take conjugate of imag part//find constant to shift H distribution by int nim1, njm1, count=0; double Havout; n=0; while(count==0) {   j = (n%Ly);     i = (n-j)/Ly;   nim1 = ip(i,-1)*Ly + j;   njm1 = i*Ly + jp(j,-1);   if(dxH[nim1]==0 && dxH[n]==0 && dyH[njm1] ==0 && dyH[n]==0 && H[n]<0)   {     Havout = H[n];     count = 1;   }   n++; } //cout << "Havout = " << Havout << '\n'; for(n=0;n<Lx*Ly;n++)   {           H[n] -= Havout;   //H is defined on P lattice       H[n] = sqrt(H[n]*H[n]+epsilon*epsilon);   }}/*Boundary functions*/void boundary_force(void) //edited for elastic boundary{  int i,j,n,nx,ny,np,s,ih,jh,ih1,jh1;  double tmag,dXds;  double nxc,nyc;  double spring_k = 0.000157, seglength, segdiff; //added these three new variables for(i=0;i<Lx;i++)    {      for(j=0;j<Ly;j++)	{	  n = i*Ly + j;	  fx[n] = 0;    	  fy[n] = 0;        //initialise boundary forces	}    }  for(s=0;s<Ls;s++)        {       tvx[s] = dsf_(Xt,s);   //get tangent (defined on s1 lat)       tvy[s] = dsf_(Yt,s);      tmag = sqrt(tvx[s]*tvx[s]+tvy[s]*tvy[s]);      tvx[s] = tvx[s]/tmag;             tvy[s] = tvy[s]/tmag;  //normalise      nvx[s] = tvy[s];      nvy[s] = -tvx[s];    //get normal vector on s1 lat      stx[s] = ST*tvx[s];      sty[s] = ST*tvy[s];#if CONC      stx[s] += -(Zc*Cs[s] + 0.5*B*Cs[s]*Cs[s])*tvx[s];      sty[s] += -(Zc*Cs[s] + 0.5*B*Cs[s]*Cs[s])*tvy[s];#endif    }  for(s=0;s<Ls;s++)    {      cout << "s point=" << s; //print out point      seglength = sqrt(dxh[sp(s,-1)]*dxh[sp(s,-1)] + dyh[sp(s,-1)]*dyh[sp(s,-1)]); // Magnitude of distance between s and s-1 	if (s==0) 	{	segdiff = 0; // Zero for first point 	}	else 	{	segdiff = seglength - (20*h); // Difference in length of the spring to the left compared to equilibrium position	}      cout << "segdiff=" << segdiff << endl; //print out compression or extension of each segment      Fx[s] = dsb_(stx,s) - spring_k*segdiff*dxh[sp(s,-1)];     // spring restoring force included (second term)      Fy[s] = dsb_(sty,s) - spring_k*segdiff*dyh[sp(s,-1)];     //F defined on s lattice    }  for(s=0;s<Ls;s++)    {       ih = Xi(X[s]);        //nearest x point down      jh = Yj(Y[s]);        //nearest y point down      ih1 = Xi1(X[s]);        //nearest x point down      jh1 = Yj1(Y[s]);        //nearest y point down      for(i=-1;i<=2;i++)     //nearest 4 x points (ih+i)	{	  for(j=-1;j<=2;j++)     //nearest 4 y points(jh+j)	    {	      //distribute forces to fluid 	      nx = ip(ih,i)*Ly + jp(jh1,j);	      ny = ip(ih1,i)*Ly + jp(jh,j);	      np = ip(ih1,i)*Ly + jp(jh1,j);	      fx[nx] += Fx[s]*deltah(x[ip(ih,i)],yp[jp(jh1,j)],X[s],Y[s])*ds;  //xlat	      fy[ny] += Fy[s]*deltah(xp[ip(ih1,i)],y[jp(jh,j)],X[s],Y[s])*ds;  //ylat	    }	}    }#if WALLS  for (s=0; s<Nsw; s++)    {      if(Xw0i[s] - Xw0[s]>0.5*xlength) Fxw0[s] = WF*(Xw0i[s] - Xw0[s] - xlength);      else 	{	  if(Xw0i[s] - Xw0[s]<-0.5*xlength) Fxw0[s] = WF*(Xw0i[s] - Xw0[s] + xlength);	  else  Fxw0[s] = WF*(Xw0i[s] - Xw0[s]);	}      if(Yw0i[s] - Yw0[s]>0.5*ylength) Fyw0[s] = WF*(Yw0i[s] - Yw0[s] - ylength);      else 	{	  if(Yw0i[s] - Yw0[s]<-0.5*ylength) Fyw0[s] = WF*(Yw0i[s] - Yw0[s] + ylength);	  else  Fyw0[s] = WF*(Yw0i[s] - Yw0[s]);	}    }  int ih0,ihp0,jh0,jhp0,nx0,ny0;  for (s=0; s<Nsw; s++)    {      ih0 = Xi(Xw0[s]);        //nearest x point down      jh0 = Yj(Yw0[s]);        //nearest y point down      ihp0 = Xi1(Xw0[s]);        //nearest x point down      jhp0 = Yj1(Yw0[s]);        //nearest y point down      for(i=-1;i<=2;i++)     //nearest 4 x points (ih+i)	{	  for(j=-1;j<=2;j++)     //nearest 4 y points(jh+j)	    {	      //distribute forces to fluid  	      nx0 = ip(ih0,i)*Ly + jp(jhp0,j);	      ny0 = ip(ihp0,i)*Ly + jp(jh0,j);	      fx[nx0] += Fxw0[s]*deltah(x[ip(ih0,i)],yp[jp(jhp0,j)],Xw0[s],Yw0[s]);	      fy[ny0] += Fyw0[s]*deltah(xp[ip(ihp0,i)],y[jp(jh0,j)],Xw0[s],Yw0[s]);	    }	}    }#endif}void boundary_vel(void){  int i,j,s,n,nx,ny,np,ih,jh,ih1,jh1,ihp1,jhp1;  for(s=0;s<Ls;s++)    {      ux.surface[s] = 0;      uy.surface[s] = 0;    }    for(s=0;s<Ls;s++)    {      ih = Xi(X[s]);        //nearest x point down      jh = Yj(Y[s]);        //nearest y point down      ih1 = Xi1(X[s]);        //nearest x point down Plat      jh1 = Yj1(Y[s]);        //nearest y point down Plat      for(i=-1;i<=2;i++)     //nearest 4 x points (ih+i)	{	  for(j=-1;j<=2;j++)     //nearest 4 y points(jh+j)	    {	      nx = ip(ih,i)*Ly + jp(jh1,j);	      ny = ip(ih1,i)*Ly + jp(jh,j);	      np = ip(ihp1,i)*Ly + jp(jhp1,j);	      ux.surface[s] += ux.bulk[nx]*deltah(x[ip(ih,i)],yp[jp(jh1,j)],X[s],Y[s])*h*h;	      uy.surface[s] += uy.bulk[ny]*deltah(xp[ip(ih1,i)],y[jp(jh,j)],X[s],Y[s])*h*h;	    }	}    }#if WALLS  int ih0,jh0,ihp0,jhp0,nx0,ny0;  for (s=0; s<Nsw; s++)    {      Vxw0[s] = 0;      Vyw0[s] = 0;      ih0 = Xi(Xw0[s]);        //nearest x point down      jh0 = Yj(Yw0[s]);        //nearest y point down      ihp0 = Xi1(Xw0[s]);        //nearest x point down      jhp0 = Yj1(Yw0[s]);        //nearest y point down       for(i=-1;i<=2;i++)     //nearest 4 x points (ih+i)	{	  for(j=-1;j<=2;j++)     //nearest 4 y points(jh+j)	    {	      nx0 = ip(ih0,i)*Ly + jp(jhp0,j);	      ny0 = ip(ihp0,i)*Ly + jp(jh0,j);	      Vxw0[s] += ux.bulk[nx0]*deltah(x[ip(ih0,i)],yp[jp(jhp0,j)],Xw0[s],Yw0[s])*h*h;	      Vyw0[s] += uy.bulk[ny0]*deltah(xp[ip(ihp0,i)],y[jp(jh0,j)],Xw0[s],Yw0[s])*h*h;	    }	}    }#endif}void remesh (void){  int s;  double dsh;   for(s=0;s<Ls;s++)    //'re-mesh'    {      dsh = sqrt(dsf_(Xt,s)*dsf_(Xt,s) + dsf_(Yt,s)*dsf_(Yt,s));      if(dsh<0.65)    //remove s+1 point	{	  remove(sp(s,1)); 	}      if(dsh>1.35)    //add point between s and s+1	{	  add(s);  	}      if(fabs(ds2_(Rh,s)) > 0.05*R0/(ds*ds))  //if points are buckling        {          cout << "Removing buckled point \n";       	  remove(s);	}    }}void area_check(void){  int s;  double Xtp, Ytp, Xtpm1, Ytpm1, dtheta, diffarea, nxc, nyc;  area = 0;  for(s=0;s<Ls;s++)    {      Xtp = 0.5*(Xt[s] + Xt[sp(s,1)]);      Ytp = 0.5*(Yt[s] + Yt[sp(s,1)]);      Xtpm1 = 0.5*(Xt[sp(s,-1)] + Xt[s]);      Ytpm1 = 0.5*(Yt[sp(s,-1)] + Yt[s]);       dtheta = atan2(Ytp,Xtp) - atan2(Ytpm1,Xtpm1);      if(dtheta > M_PI) dtheta -= 2*M_PI;      if(dtheta < -M_PI) dtheta += 2*M_PI;      area += 0.5*Rh[s]*Rh[s]*dtheta;    }  diffarea = area - oldarea;  area = 0;  for(s=0;s<Ls;s++)    {      nxc = 0.5*(nvx[sp(s,-1)] + nvx[s]);      nyc = 0.5*(nvy[sp(s,-1)] + nvy[s]);      X[s] -= nxc*(sqrt(1+diffarea/oldarea)-1);      Y[s] -= nyc*(sqrt(1+diffarea/oldarea)-1);      if(X[s] < -xlength/2.0) X[s] += xlength;      if(X[s] >= xlength/2.0) X[s] -= xlength;      if(Y[s] < -ylength/2.0) Y[s] += ylength;      if(Y[s] >= ylength/2.0) Y[s] -= ylength;    }   update_spacing();  for(s=0;s<Ls;s++)    {      Xtp = 0.5*(Xt[s] + Xt[sp(s,1)]);      Ytp = 0.5*(Yt[s] + Yt[sp(s,1)]);      Xtpm1 = 0.5*(Xt[sp(s,-1)] + Xt[s]);      Ytpm1 = 0.5*(Yt[sp(s,-1)] + Yt[s]);       dtheta = atan2(Ytp,Xtp) - atan2(Ytpm1,Xtpm1);      if(dtheta > M_PI) dtheta -= 2*M_PI;      if(dtheta < -M_PI) dtheta += 2*M_PI;      area += 0.5*Rh[s]*Rh[s]*dtheta;    }  diffarea = area - oldarea; }void remove(int a){  int k;  //cout << "removed a point at (" << X[a] << "," << Y[a] << ")\n";#if CONC  Cs[sp(a,-1)] = ds*(Cs[sp(a,-1)]*sqrt(dsf_(Xt,sp(a,-1))*dsf_(Xt,sp(a,-1)) + dsf_(Yt,sp(a,-1))*dsf_(Yt,sp(a,-1))) + Cs[a]*sqrt(dsf_(Xt,a)*dsf_(Xt,a) + dsf_(Yt,a)*dsf_(Yt,a)))/sqrt((Xt[sp(a,1)] - Xt[sp(a,-1)])*(Xt[sp(a,1)] - Xt[sp(a,-1)]) + (Yt[sp(a,1)] - Yt[sp(a,-1)])*(Yt[sp(a,1)] - Yt[sp(a,-1)]));#endif  for(k=a;k<Ls-1;k++)  //up to Ls-2, shift all points down 1 in s    {	  X[k] = X[k+1];	  Y[k] = Y[k+1];#if CONC	  Cs[k] = Cs[k+1];#endif    } Ls--;  //reduce total points by 1  update_spacing();}void add(int a){  int k,s;  for(k=Ls-1;k>a;k--)    {	  X[k+1] = X[k];	  Y[k+1] = Y[k];#if CONC	  Cs[k+1] = Cs[k];#endif    }  Ls++;     //increase total s points by 1  X[a+1] = X[a] + dxh[a]/2.0;  Y[a+1] = Y[a] + dyh[a]/2.0; //add coordinate of new point at a+1#if CONC  Cs[a+1] = Cs[a];    //new concentration#endif  //cout << "added a point at (" << X[a+1] << "," << Y[a+1] << ")\n";  update_spacing();}void update_spacing(void){  int s,i;  double Xh = X[0];  double Yh = Y[0];  double Xmax = -xlength/2.0;  double Ymax = -ylength/2.0;  double Xmin = xlength/2.0;  double Ymin = ylength/2.0;  int sxmax = 0;  int symax = 0;  int sxmin = 0;  int symin = 0;  for(s=0;s<Ls;s++)    {      dxh[s] = X[sp(s,1)]-X[s];      if(dxh[s]>xlength/2) //crosses left boundary	{	  dxh[s]-=xlength;	}      if(dxh[s]<-xlength/2)  //crosses right boundary	{	  dxh[s]+=xlength;	}      dyh[s] = Y[sp(s,1)]-Y[s];  //crosses bottom boundary      if(dyh[s]>ylength/2) 	{	  dyh[s]-=ylength;	}      if(dyh[s]<-ylength/2)   //crosses top boundary	{	  dyh[s]+=ylength;	}      Xp[s] = X[s] + 0.5*dxh[s];      if(Xp[s]>=xlength/2) Xp[s] -= xlength;      if(Xp[s]<-xlength/2) Xp[s] += xlength;      Yp[s] = Y[s] + 0.5*dyh[s];      if(Yp[s]>=ylength/2) Yp[s] -= ylength;      if(Yp[s]<-ylength/2) Yp[s] += ylength;      Xh += dxh[s];      Yh += dyh[s];      //maxs and mins for s=0 ref frame      if(Xh>Xmax) 	{	  Xmax = Xh;	  sxmax = s;	}     if(Xh<Xmin) 	{	  Xmin = Xh;	  sxmin = s;	}     if(Yh>Ymax) 	{	  Ymax = Yh;	  symax = s;	}     if(Yh<Ymin) 	{	  Ymin = Yh;	  symin = s;	}      slength += sqrt(dxh[s]*dxh[s]+dyh[s]*dyh[s]);    }  if(X[sxmin]<X[sxmax])    {      xcom = (X[sxmin]+X[sxmax])/2.0;    }  else    {      if(X[sxmax]>-X[sxmin]) xcom = (X[sxmax] - xlength + X[sxmin])/2.0;      else xcom = (X[sxmax] + xlength + X[sxmin])/2.0;  //resume here    }  if(Y[symin]<Y[symax])    {       ycom = (Y[symin]+Y[symax])/2.0;    }  else    {      if(Y[symax]>-Y[symin]) ycom = (Y[symax] - ylength + Y[symin])/2.0;      else ycom = (Y[symax] + ylength + Y[symin])/2.0;  //resume here    }  icom = (int) (xcom + xlength/2)/h;  jcom = (int) (ycom + ylength/2)/h;  double dXds,xh,yh;  xcomp = 0;  ycomp = 0;  double norm = 0;    for(s=0;s<Ls;s++)    {      dXds = 0.5*sqrt(dxh[sp(s,-1)]*dxh[sp(s,-1)] + dyh[sp(s,-1)]*dyh[sp(s,-1)])/ds + 0.5*sqrt(dxh[s]*dxh[s] + dyh[s]*dyh[s])/ds;      xh = X[s]-xcom;      if(xh>=xlength/2.0) xh -= xlength;      if(xh<-xlength/2.0) xh += xlength;      yh = Y[s]-ycom;      if(yh>=ylength/2.0) yh -= ylength;      if(yh<-ylength/2.0) yh += ylength;      xcomp += xh*dXds*ds;      ycomp += yh*dXds*ds;      norm += dXds*ds;     }    xcomp = xcomp/norm;     ycomp = ycomp/norm;  xcomp += xcom;  ycomp += ycom;  //proper centre of mass  update_tlat();  //cout << "Boundarylength=" << slength << endl; //added to monitor length of boundary after each iteration}void update_tlat(void){  int i,j,s;  for(s=0;s<Ls;s++)    {          Xt[s] = X[s]-xcomp;      if(Xt[s]>=xlength/2.0) Xt[s] -= xlength;      if(Xt[s]<-xlength/2.0) Xt[s] += xlength;      Yt[s] = Y[s]-ycomp;      if(Yt[s]>=ylength/2.0) Yt[s] -= ylength;      if(Yt[s]<-ylength/2.0) Yt[s] += ylength;      Rh[s] = sqrt(Xt[s]*Xt[s] + Yt[s]*Yt[s]);    }}void perturbation(void){  int i,s;  int order = max(Ls/4,1);  //order to go up to with perturbation sum  double k1,k2,theta;  srand48(time(NULL));#if BULKPOLW1 = 0;#endif  update_spacing();  update_tlat();}/*Mathematical functions*/#if WALLSdouble bottom_wall_position(double xh)     //bottom wall position as a function of x{  if(fabs(xh) <= (xlength/2 - transition_length)/2) return (-s_width/2);  if(fabs(xh) > (xlength/2 - transition_length)/2 && fabs(xh) < (xlength/2 + transition_length)/2)     {      return (-s_width/2 + (fabs(xh) - (xlength/2 - transition_length)/2)*(s_width-chan_width)/(2*transition_length));    }  if(fabs(xh) >= (xlength/2 + transition_length)/2) return (-chan_width/2);}double top_wall_position(double xh)        //top wall position as a function of x{  if(fabs(xh) <= (xlength/2 - transition_length)/2) return (s_width/2);  if(fabs(xh) > (xlength/2 - transition_length)/2 && fabs(xh) < (xlength/2 + transition_length)/2)     {      return (s_width/2 - (fabs(xh) - (xlength/2 - transition_length)/2)*(s_width-chan_width)/(2*transition_length));    }  if(fabs(xh) >= (xlength/2 + transition_length)/2) return (chan_width/2);}#endif double deltah(double xi, double yj, double Xs, double Ys)     //soft delta function{  double xdiff,ydiff,phix,phiy,result;  xdiff = (xi - Xs)/h;  if(xdiff > 0.5*xlength/h) xdiff -= xlength/h;  if(xdiff < -0.5*xlength/h) xdiff += xlength/h;  ydiff = (yj - Ys)/h;  if(ydiff > 0.5*ylength/h) ydiff -= ylength/h;  if(ydiff < -0.5*ylength/h) ydiff += ylength/h;  phix = phir(xdiff);      //get individual phis  phiy = phir(ydiff);  result = phix*phiy/(h*h);  return result;}double phir(double r)            //factors of delta function{  double result;  result=0;  if(r>-2 && r<-1) result = (5+2*r-sqrt(-7-12*r-4*r*r))/8.0;  if(r>=-1 && r<0) result = (3+2*r+sqrt(1-4*r-4*r*r))/8.0;  if(r>=0 && r<=1) result = (3-2*r+sqrt(1+4*r-4*r*r))/8.0;  if(r>1 && r<2) result = (5-2*r-sqrt(-7+12*r-4*r*r))/8.0;  return result;}int ip(int i, int p){  if(i+p>Lx-1) return (i+p)%Lx;  else if (i+p<0) return Lx+(i+p);  else return i+p;}int jp(int j, int p){  if(j+p>Ly-1) return (j+p)%Ly;  else if (j+p<0) return Ly+(j+p);  else return j+p;} int sp(int s, int p){  if(s+p>Ls-1) return (s+p)%Ls;  else if (s+p<0) return Ls+(s+p);  else return s+p;}double dsf_(double *f, int s)   //gradient at s+1/2{  return ((f[sp(s,1)] - f[s])/ds);}double dsb_(double *f, int s)   //gradient at s+1/2{  return ((f[s] - f[sp(s,-1)])/ds);}double ds2_(double *f, int s)   //gradient at s+1/2{  double result;  double ds1,ds2;  ds1 = sqrt(dxh[s]*dxh[s]+dyh[s]*dyh[s]);   //distance between s & s+1  ds2 = sqrt(dxh[sp(s,-1)]*dxh[sp(s,-1)]+dyh[sp(s,-1)]*dyh[sp(s,-1)]);  //distance between s & s-1  result = 2.0*(-(1/ds1 + 1/ds2)*f[s] + f[sp(s,1)]/ds1 + f[sp(s,-1)]/ds2)/(ds1+ds2);}double dxf_(double f[Lx*Ly], int i, int j){  int n = i*Ly + j;  int nup = ip(i,1)*Ly+j;  return (f[nup]-f[n])/(h);}double dxb_(double f[Lx*Ly], int i, int j){  int n = i*Ly + j;  int ndwn = ip(i,-1)*Ly+j;  return (f[n]-f[ndwn])/(h);}double dyf_(double f[Lx*Ly], int i, int j){  int n = i*Ly + j;  int nup = i*Ly+jp(j,1);  return (f[nup]-f[n])/(h);}double dyb_(double f[Lx*Ly], int i, int j){  int n = i*Ly + j;  int ndwn = i*Ly+jp(j,-1);  return (f[n]-f[ndwn])/(h);}double dx2_(double f[Lx*Ly], int i, int j){  int n = i*Ly + j;  int nup = ip(i,1)*Ly+j;  int ndwn = ip(i,-1)*Ly+j;  return ((f[nup] - 2*f[n] + f[ndwn])/(h*h));  //central diff}double dy2_(double f[Lx*Ly], int i, int j){  int n = i*Ly + j;  int nup = i*Ly+jp(j,1);  int ndwn = i*Ly+jp(j,-1);  return ((f[nup] - 2*f[n] + f[ndwn])/(h*h));  //central diff}double vdelx(double f[Lx*Ly], double v, int i, int j){  int nup2 = ip(i,2)*Ly + j;  int nup = ip(i,1)*Ly + j;  int n = i*Ly + j;  int ndwn = ip(i,-1)*Ly + j;  int ndwn2 = ip(i,-2)*Ly + j;  if(v>0) return (v*(2*f[nup] + 3*f[n] - 6*f[ndwn] + f[ndwn2])/(6*h));  else return (v*(-f[nup2] + 6*f[nup] - 3*f[n] - 2*f[ndwn])/(6*h));}double vdely(double f[Lx*Ly], double v, int i, int j){  int nup2 = i*Ly + jp(j,2);  int nup = i*Ly + jp(j,1);  int n = i*Ly + j;  int ndwn = i*Ly + jp(j,-1);  int ndwn2 = i*Ly + jp(j,-2);  if(v>0) return (v*(2*f[nup] + 3*f[n] - 6*f[ndwn] + f[ndwn2])/(6*h));  else return (v*(-f[nup2] + 6*f[nup] - 3*f[n] - 2*f[ndwn])/(6*h));}int Xi1(double Xs){  double ih = (Xs + xlength/2)/h - 0.5;  if(ih<0) return (Lx-1+((int) (ih)));  else return ((int) ih);}int Yj1(double Ys){  double jh = (Ys + ylength/2)/h - 0.5;  if(jh<0) return (Ly-1+((int) (jh)));  else return ((int) jh);}int Xi(double Xs){  return ((int) ((Xs + xlength/2)/h));}int Yj(double Ys){  return ((int) ((Ys + ylength/2)/h));}double p2xlat(double *f, int n){  int j = n%Ly;  int i = (n-j)/Ly;  return ((f[n] + f[ip(i,-1)*Ly+j])/2.0);   //average between i+1/2 and i-1/2}double p2ylat(double *f, int n){  int j = n%Ly;  int i = (n-j)/Ly;  return ((f[n] + f[i*Ly+jp(j,-1)])/2.0);   //average between j+1/2 and j-1/2}double p2blat(double *f, int n){  int j = n%Ly;  int i = (n-j)/Ly;  return ((f[n] + f[ip(i,-1)*Ly+j] + f[i*Ly+jp(j,-1)] + f[ip(i,-1)*Ly+jp(j,-1)])/4.0);   //average between (i+1/2,j+1/2),(i-1/2,j+1/2),(i+1/2,j-1/2) and (i-1/2,j-1/2)}double x2plat(double *f, int n){  int j = n%Ly;  int i = (n-j)/Ly;  return ((f[n] + f[ip(i,1)*Ly+j])/2.0);   //average between i and i+1}double y2plat(double *f, int n){  int j = n%Ly;  int i = (n-j)/Ly;  return ((f[n] + f[i*Ly+jp(j,1)])/2.0);   //average between j and j+1}void plotfile(void){  ofstream printfile;  double vscale;  printfile.open("plotsims.sh");  vscale = 20;#if BULKPOL  if(fabs(Zeta) > K) vscale /= fabs(Zeta/K);#endif#if CONC  if(fabs(Zc) > 5*Df) vscale /= fabs(Zc/Df);#endif#if WALLS  vscale *= 2;#endif  printfile << "#!/bin/sh \n\n#shell script for calling gnuplot \n\n#sets the name of the files \nnumber=$1   #file number \ninput1=\"bulk\"$number\".txt\" \ninput2=\"boundary\"$number\".txt\" \n";#if WALLS  printfile << "input3=\"walls\"$number\".txt\" \n";#endif  printfile << "timestep=$((250 * 10#$number))" << '\n'; //as long as my stepskip is 250, this puts the timestep in the plotfile  printfile << "vscale=" << vscale << '\n';  printfile << "output1=\"Plot\"$number\".eps\" \n\n";  printfile << gnuheader() << '\n';  printfile << "set terminal postscript enhanced color eps \n";  printfile << "set output \"$output1\" \n";#if WALLS  printfile << "set size 1,0.5 \n";#else  printfile << "set size square \n";#endif#if CONC  printfile << "set palette defined (0 \"black\", 1 \"red\", 2 \"yellow\") \n";  printfile << "set cblabel \"Concentration/Steady State Concentration\" \n";#else  printfile << "set palette defined (0 \"white\", 1 \"black\") \n";  printfile << "set cbrange [0:1] \n";  printfile << "set cblabel \"|p|\" \n";#endif  printfile << "set xrange [" << -0.5*xlength << ':' << 0.5*xlength << "] \n";  printfile << "set yrange [" << -0.5*ylength << ':' << 0.5*ylength << "] \n";  printfile << "set xlabel \"x \" \n";  printfile << "set xlabel \"y \" \nplot ";#if BULKPOL#if !CONC  printfile << "\"$input1\" u 1:2:(sqrt(\\$5*\\$5+\\$6*\\$6)) palette pt 5 ps 2 t '', ";#endif#endif#if CONC  if(koff>0) printfile << "\"$input1\" u 1:2:(\\$5*\\$9/" << cbulk0 << ") palette pt 5 ps 2 t '', ";#endif  printfile << "\"$input1\" u 1:2:(\\$3*$vscale):(\\$4*$vscale) w vectors lc 3 t '', \"$input2\" u 1:2";#if CONC  printfile << ":(\\$5/" << conc0 << ") palette pt 5 ps 1 t ''";#else   printfile << "pt 13 ps 1 lc rgb '#bc1abf' t ''";#endif#if WALLS  printfile << ", \"$input3\" u 1:2 pt 5 ps 1 lc 0, \"$input3\" u 3:4 pt 5 ps 1 lc 0";#endif   printfile << "\nEOF";}string gnuheader(void){  return "#calls gnuplot, but leaves the input file unfinished \ngnuplot -persist <<EOF  \n#this is now effectively a gnuplot file, but with the variable name. \n#below are the default settings for every plot (I can change them if I want). \n#     \n#    	G N U P L O T \n#    	Version 4.4 patchlevel 0 \n#    	last modified March 2010 \n#    	System: Linux 2.6.35-27-generic \n#     \n#    	Copyright (C) 1986-1993, 1998, 2004, 2007-2010 \n#    	Thomas Williams, Colin Kelley and many others \n#     \n#    	gnuplot home:     http://www.gnuplot.info \n#    	faq, bugs, etc:   type \"help seeking-assistance\" \n#    	immediate help:   type \"help\" \n#    	plot window:      hit 'h' \n# set terminal wxt 0 \n# set output \nunset clip points \nset clip one \nunset clip two \nset bar 1.000000 front \nset border 31 front linetype -1 linewidth 1.000 \nset xdata \nset ydata \nset zdata \nset x2data \nset y2data \nset timefmt x \"\%d/\%m/\%y,\%H:\%M\" \nset timefmt y \"\%d/\%m/\%y,\%H:\%M\" \nset timefmt z \"\%d/\%m/\%y,\%H:\%M\" \nset timefmt x2 \"\%d/\%m/\%y,\%H:\%M\" \nset timefmt y2 \"\%d/\%m/\%y,\%H:\%M\" \nset timefmt cb \"\%d/\%m/\%y,\%H:\%M\" \nset boxwidth \nset style fill  empty border \nset style rectangle back fc lt -3 fillstyle   solid 1.00 border lt -1 \nset dummy x,y \nset format x \"\% g\" \nset format y \"\% g\" \nset format x2 \"\% g\" \nset format y2 \"\% g\" \nset format z \"\% g\" \nset format cb \"\% g\" \nset angles radians \nunset grid \nset key title \"\" \nset key inside right top vertical Right noreverse enhanced autotitles nobox \nset key noinvert samplen 4 spacing 1 width 0 height 0  \nunset label \nunset arrow \nset style increment default \nunset style line \nunset style arrow \nset style histogram clustered gap 2 title  offset character 0, 0, 0 \nunset logscale \nset offsets 0, 0, 0, 0 \nset pointsize 5 \nset encoding default \nunset polar \nunset parametric \nunset decimalsign \nset view 60, 30, 1, 1   \nset samples 100, 100 \nset isosamples 10, 10 \nset surface \nunset contour \nset clabel '\%8.3g' \nset mapping cartesian \nset datafile separator whitespace \nunset hidden3d \nset cntrparam order 4 \nset cntrparam linear \nset cntrparam levels auto 5 \nset cntrparam points 5 \nset size ratio 0 1,1 \nset origin 0,0 \nset style data points \nset style function lines \nset xzeroaxis linetype -2 linewidth 1.000 \nset yzeroaxis linetype -2 linewidth 1.000 \nset zzeroaxis linetype -2 linewidth 1.000 \nset x2zeroaxis linetype -2 linewidth 1.000 \nset y2zeroaxis linetype -2 linewidth 1.000 \nset ticslevel 0.5 \nset mxtics default \nset mytics default \nset mztics default \nset mx2tics default \nset my2tics default \nset mcbtics default \nset xtics border in scale 1,0.5 mirror norotate  offset character 0, 0, 0 \nset xtics autofreq  norangelimit \nset ytics border in scale 1,0.5 mirror norotate  offset character 0, 0, 0 \nset ytics autofreq  norangelimit \nset ztics border in scale 1,0.5 nomirror norotate  offset character 0, 0, 0 \nset ztics autofreq  norangelimit \nset nox2tics \nset noy2tics \nset cbtics border in scale 1,0.5 mirror norotate  offset character 0, 0, 0 \nset cbtics autofreq  norangelimit \nset title \"\"  \nset title  offset character 0, 0, 0 font \"\" norotate \nset timestamp bottom  \nset timestamp \"Time = $timestep \"  \nset timestamp  offset character 0, 0, 0 font \"\" norotate \nset rrange [ * : * ] noreverse nowriteback  # (currently [-10.0000:10.0000] ) \nset trange [ * : * ] noreverse nowriteback  # (currently [-10.0000:10.0000] ) \nset urange [ * : * ] noreverse nowriteback  # (currently [-10.0000:10.0000] ) \nset vrange [ * : * ] noreverse nowriteback  # (currently [-10.0000:10.0000] ) \nset xlabel \"\"  \nset xlabel  offset character 0, 0, 0 font \"\" textcolor lt -1 norotate \nset x2label \"\"  \nset x2label  offset character 0, 0, 0 font \"\" textcolor lt -1 norotate \nset xrange [ * : * ] noreverse nowriteback  # (currently [-10.0000:10.0000] ) \nset x2range [ * : * ] noreverse nowriteback  # (currently [-10.0000:10.0000] ) \nset ylabel \"\"  \nset ylabel  offset character 0, 0, 0 font \"\" textcolor lt -1 rotate by -270 \nset y2label \"\"  \nset y2label  offset character 0, 0, 0 font \"\" textcolor lt -1 rotate by -270 \nset yrange [ * : * ] noreverse nowriteback  # (currently [-10.0000:10.0000] ) \nset y2range [ * : * ] noreverse nowriteback  # (currently [-10.0000:10.0000] ) \nset zlabel \"\"  \nset zlabel  offset character 0, 0, 0 font \"\" textcolor lt -1 norotate \nset zrange [ * : * ] noreverse nowriteback  # (currently [-10.0000:10.0000] ) \nset cblabel \"\"  \nset cblabel  offset character 0, 0, 0 font \"\" textcolor lt -1 rotate by -270 \nset cbrange [ * : * ] noreverse nowriteback  # (currently [-10.0000:10.0000] ) \nset zero 1e-08 \nset lmargin  -1 \nset bmargin  -1 \nset rmargin  -1 \nset tmargin  -1 \n#set locale \"en_GB.UTF-8\" \nset pm3d explicit at s \nset pm3d scansautomatic \nset pm3d interpolate 1,1 flush begin noftriangles nohidden3d corners2color mean \nset palette positive nops_allcF maxcolors 0 gamma 1.5 color model RGB  \nset palette rgbformulae 7, 5, 15 \nset colorbox default \nset colorbox vertical origin screen 0.9, 0.2, 0 size screen 0.05, 0.6, 0 front bdefault \nset loadpath  \nset fontpath  \nset fit noerrorvariables \n############################################################################ \n####################This is the end of the default settings. \n############################################################################";}